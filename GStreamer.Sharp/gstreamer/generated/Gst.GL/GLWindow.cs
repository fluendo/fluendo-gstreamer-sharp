// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Gst.GL {

	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.Runtime.InteropServices;

#region Autogenerated code
	public partial class GLWindow : Gst.Object {

		protected GLWindow (IntPtr raw) : base(raw) {}

		[DllImport("gstgl-1.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gst_gl_window_new(IntPtr display);

		public GLWindow (Gst.GL.GLDisplay display) : base (IntPtr.Zero)
		{
			if (GetType () != typeof (GLWindow)) {
				var vals = new List<GLib.Value> ();
				var names = new List<string> ();
				CreateNativeObject (names.ToArray (), vals.ToArray ());
				return;
			}
			Raw = gst_gl_window_new(display == null ? IntPtr.Zero : display.Handle);
		}

		[DllImport("gstgl-1.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern UIntPtr gst_gl_window_get_display(IntPtr raw);

		public ulong Display {
			get  {
				UIntPtr raw_ret = gst_gl_window_get_display(Handle);
				ulong ret = (ulong) raw_ret;
				return ret;
			}
		}

		[GLib.Signal("key-event")]
		public event Gst.GL.KeyEventHandler KeyEvent {
			add {
				this.AddSignalHandler ("key-event", value, typeof (Gst.GL.KeyEventArgs));
			}
			remove {
				this.RemoveSignalHandler ("key-event", value);
			}
		}

		[GLib.Signal("scroll-event")]
		public event Gst.GL.ScrollEventHandler ScrollEvent {
			add {
				this.AddSignalHandler ("scroll-event", value, typeof (Gst.GL.ScrollEventArgs));
			}
			remove {
				this.RemoveSignalHandler ("scroll-event", value);
			}
		}

		[GLib.Signal("mouse-event")]
		public event Gst.GL.MouseEventHandler MouseEvent {
			add {
				this.AddSignalHandler ("mouse-event", value, typeof (Gst.GL.MouseEventArgs));
			}
			remove {
				this.RemoveSignalHandler ("mouse-event", value);
			}
		}

		static KeyEventNativeDelegate KeyEvent_cb_delegate;
		static KeyEventNativeDelegate KeyEventVMCallback {
			get {
				if (KeyEvent_cb_delegate == null)
					KeyEvent_cb_delegate = new KeyEventNativeDelegate (KeyEvent_cb);
				return KeyEvent_cb_delegate;
			}
		}

		static void OverrideKeyEvent (GLib.GType gtype)
		{
			OverrideKeyEvent (gtype, KeyEventVMCallback);
		}

		static void OverrideKeyEvent (GLib.GType gtype, KeyEventNativeDelegate callback)
		{
			OverrideVirtualMethod (gtype, "key-event", callback);
		}
		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void KeyEventNativeDelegate (IntPtr inst, IntPtr id, IntPtr key);

		static void KeyEvent_cb (IntPtr inst, IntPtr id, IntPtr key)
		{
			try {
				GLWindow __obj = GLib.Object.GetObject (inst, false) as GLWindow;
				__obj.OnKeyEvent (GLib.Marshaller.Utf8PtrToString (id), GLib.Marshaller.Utf8PtrToString (key));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gst.GL.GLWindow), ConnectionMethod="OverrideKeyEvent")]
		protected virtual void OnKeyEvent (string id, string key)
		{
			InternalKeyEvent (id, key);
		}

		private void InternalKeyEvent (string id, string key)
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (3);
			GLib.Value[] vals = new GLib.Value [3];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			vals [1] = new GLib.Value (id);
			inst_and_params.Append (vals [1]);
			vals [2] = new GLib.Value (key);
			inst_and_params.Append (vals [2]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		static MouseEventNativeDelegate MouseEvent_cb_delegate;
		static MouseEventNativeDelegate MouseEventVMCallback {
			get {
				if (MouseEvent_cb_delegate == null)
					MouseEvent_cb_delegate = new MouseEventNativeDelegate (MouseEvent_cb);
				return MouseEvent_cb_delegate;
			}
		}

		static void OverrideMouseEvent (GLib.GType gtype)
		{
			OverrideMouseEvent (gtype, MouseEventVMCallback);
		}

		static void OverrideMouseEvent (GLib.GType gtype, MouseEventNativeDelegate callback)
		{
			OverrideVirtualMethod (gtype, "mouse-event", callback);
		}
		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void MouseEventNativeDelegate (IntPtr inst, IntPtr id, int button, double x, double y);

		static void MouseEvent_cb (IntPtr inst, IntPtr id, int button, double x, double y)
		{
			try {
				GLWindow __obj = GLib.Object.GetObject (inst, false) as GLWindow;
				__obj.OnMouseEvent (GLib.Marshaller.Utf8PtrToString (id), button, x, y);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gst.GL.GLWindow), ConnectionMethod="OverrideMouseEvent")]
		protected virtual void OnMouseEvent (string id, int button, double x, double y)
		{
			InternalMouseEvent (id, button, x, y);
		}

		private void InternalMouseEvent (string id, int button, double x, double y)
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (5);
			GLib.Value[] vals = new GLib.Value [5];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			vals [1] = new GLib.Value (id);
			inst_and_params.Append (vals [1]);
			vals [2] = new GLib.Value (button);
			inst_and_params.Append (vals [2]);
			vals [3] = new GLib.Value (x);
			inst_and_params.Append (vals [3]);
			vals [4] = new GLib.Value (y);
			inst_and_params.Append (vals [4]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		static ScrollEventNativeDelegate ScrollEvent_cb_delegate;
		static ScrollEventNativeDelegate ScrollEventVMCallback {
			get {
				if (ScrollEvent_cb_delegate == null)
					ScrollEvent_cb_delegate = new ScrollEventNativeDelegate (ScrollEvent_cb);
				return ScrollEvent_cb_delegate;
			}
		}

		static void OverrideScrollEvent (GLib.GType gtype)
		{
			OverrideScrollEvent (gtype, ScrollEventVMCallback);
		}

		static void OverrideScrollEvent (GLib.GType gtype, ScrollEventNativeDelegate callback)
		{
			OverrideVirtualMethod (gtype, "scroll-event", callback);
		}
		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ScrollEventNativeDelegate (IntPtr inst, double x, double y, double delta_x, double delta_y);

		static void ScrollEvent_cb (IntPtr inst, double x, double y, double delta_x, double delta_y)
		{
			try {
				GLWindow __obj = GLib.Object.GetObject (inst, false) as GLWindow;
				__obj.OnScrollEvent (x, y, delta_x, delta_y);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gst.GL.GLWindow), ConnectionMethod="OverrideScrollEvent")]
		protected virtual void OnScrollEvent (double x, double y, double delta_x, double delta_y)
		{
			InternalScrollEvent (x, y, delta_x, delta_y);
		}

		private void InternalScrollEvent (double x, double y, double delta_x, double delta_y)
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (5);
			GLib.Value[] vals = new GLib.Value [5];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			vals [1] = new GLib.Value (x);
			inst_and_params.Append (vals [1]);
			vals [2] = new GLib.Value (y);
			inst_and_params.Append (vals [2]);
			vals [3] = new GLib.Value (delta_x);
			inst_and_params.Append (vals [3]);
			vals [4] = new GLib.Value (delta_y);
			inst_and_params.Append (vals [4]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		static GetDisplayNativeDelegate GetDisplay_cb_delegate;
		static GetDisplayNativeDelegate GetDisplayVMCallback {
			get {
				if (GetDisplay_cb_delegate == null)
					GetDisplay_cb_delegate = new GetDisplayNativeDelegate (GetDisplay_cb);
				return GetDisplay_cb_delegate;
			}
		}

		static void OverrideGetDisplay (GLib.GType gtype)
		{
			OverrideGetDisplay (gtype, GetDisplayVMCallback);
		}

		static void OverrideGetDisplay (GLib.GType gtype, GetDisplayNativeDelegate callback)
		{
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) gtype.GetClassPtr()) + (long) class_abi.GetFieldOffset("get_display"));
				*raw_ptr = Marshal.GetFunctionPointerForDelegate((Delegate) callback);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate UIntPtr GetDisplayNativeDelegate (IntPtr inst);

		static UIntPtr GetDisplay_cb (IntPtr inst)
		{
			try {
				GLWindow __obj = GLib.Object.GetObject (inst, false) as GLWindow;
				ulong __result;
				__result = __obj.OnGetDisplay ();
				return new UIntPtr (__result);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gst.GL.GLWindow), ConnectionMethod="OverrideGetDisplay")]
		protected virtual ulong OnGetDisplay ()
		{
			return InternalGetDisplay ();
		}

		private ulong InternalGetDisplay ()
		{
			GetDisplayNativeDelegate unmanaged = null;
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) this.LookupGType().GetThresholdType().GetClassPtr()) + (long) class_abi.GetFieldOffset("get_display"));
				unmanaged = (GetDisplayNativeDelegate) Marshal.GetDelegateForFunctionPointer(*raw_ptr, typeof(GetDisplayNativeDelegate));
			}
			if (unmanaged == null) return 0;

			UIntPtr __result = unmanaged (this.Handle);
			return (ulong) __result;
		}

		static SetWindowHandleNativeDelegate SetWindowHandle_cb_delegate;
		static SetWindowHandleNativeDelegate SetWindowHandleVMCallback {
			get {
				if (SetWindowHandle_cb_delegate == null)
					SetWindowHandle_cb_delegate = new SetWindowHandleNativeDelegate (SetWindowHandle_cb);
				return SetWindowHandle_cb_delegate;
			}
		}

		static void OverrideSetWindowHandle (GLib.GType gtype)
		{
			OverrideSetWindowHandle (gtype, SetWindowHandleVMCallback);
		}

		static void OverrideSetWindowHandle (GLib.GType gtype, SetWindowHandleNativeDelegate callback)
		{
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) gtype.GetClassPtr()) + (long) class_abi.GetFieldOffset("set_window_handle"));
				*raw_ptr = Marshal.GetFunctionPointerForDelegate((Delegate) callback);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void SetWindowHandleNativeDelegate (IntPtr inst, UIntPtr handle);

		static void SetWindowHandle_cb (IntPtr inst, UIntPtr handle)
		{
			try {
				GLWindow __obj = GLib.Object.GetObject (inst, false) as GLWindow;
				__obj.OnSetWindowHandle ((ulong) handle);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gst.GL.GLWindow), ConnectionMethod="OverrideSetWindowHandle")]
		protected virtual void OnSetWindowHandle (ulong handle)
		{
			InternalSetWindowHandle (handle);
		}

		private void InternalSetWindowHandle (ulong handle)
		{
			SetWindowHandleNativeDelegate unmanaged = null;
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) this.LookupGType().GetThresholdType().GetClassPtr()) + (long) class_abi.GetFieldOffset("set_window_handle"));
				unmanaged = (SetWindowHandleNativeDelegate) Marshal.GetDelegateForFunctionPointer(*raw_ptr, typeof(SetWindowHandleNativeDelegate));
			}
			if (unmanaged == null) return;

			unmanaged (this.Handle, new UIntPtr (handle));
		}

		static GetWindowHandleNativeDelegate GetWindowHandle_cb_delegate;
		static GetWindowHandleNativeDelegate GetWindowHandleVMCallback {
			get {
				if (GetWindowHandle_cb_delegate == null)
					GetWindowHandle_cb_delegate = new GetWindowHandleNativeDelegate (GetWindowHandle_cb);
				return GetWindowHandle_cb_delegate;
			}
		}

		static void OverrideGetWindowHandle (GLib.GType gtype)
		{
			OverrideGetWindowHandle (gtype, GetWindowHandleVMCallback);
		}

		static void OverrideGetWindowHandle (GLib.GType gtype, GetWindowHandleNativeDelegate callback)
		{
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) gtype.GetClassPtr()) + (long) class_abi.GetFieldOffset("get_window_handle"));
				*raw_ptr = Marshal.GetFunctionPointerForDelegate((Delegate) callback);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate UIntPtr GetWindowHandleNativeDelegate (IntPtr inst);

		static UIntPtr GetWindowHandle_cb (IntPtr inst)
		{
			try {
				GLWindow __obj = GLib.Object.GetObject (inst, false) as GLWindow;
				ulong __result;
				__result = __obj.OnGetWindowHandle ();
				return new UIntPtr (__result);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gst.GL.GLWindow), ConnectionMethod="OverrideGetWindowHandle")]
		protected virtual ulong OnGetWindowHandle ()
		{
			return InternalGetWindowHandle ();
		}

		private ulong InternalGetWindowHandle ()
		{
			GetWindowHandleNativeDelegate unmanaged = null;
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) this.LookupGType().GetThresholdType().GetClassPtr()) + (long) class_abi.GetFieldOffset("get_window_handle"));
				unmanaged = (GetWindowHandleNativeDelegate) Marshal.GetDelegateForFunctionPointer(*raw_ptr, typeof(GetWindowHandleNativeDelegate));
			}
			if (unmanaged == null) return 0;

			UIntPtr __result = unmanaged (this.Handle);
			return (ulong) __result;
		}

		static DrawNativeDelegate Draw_cb_delegate;
		static DrawNativeDelegate DrawVMCallback {
			get {
				if (Draw_cb_delegate == null)
					Draw_cb_delegate = new DrawNativeDelegate (Draw_cb);
				return Draw_cb_delegate;
			}
		}

		static void OverrideDraw (GLib.GType gtype)
		{
			OverrideDraw (gtype, DrawVMCallback);
		}

		static void OverrideDraw (GLib.GType gtype, DrawNativeDelegate callback)
		{
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) gtype.GetClassPtr()) + (long) class_abi.GetFieldOffset("draw"));
				*raw_ptr = Marshal.GetFunctionPointerForDelegate((Delegate) callback);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void DrawNativeDelegate (IntPtr inst);

		static void Draw_cb (IntPtr inst)
		{
			try {
				GLWindow __obj = GLib.Object.GetObject (inst, false) as GLWindow;
				__obj.OnDraw ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gst.GL.GLWindow), ConnectionMethod="OverrideDraw")]
		protected virtual void OnDraw ()
		{
			InternalDraw ();
		}

		private void InternalDraw ()
		{
			DrawNativeDelegate unmanaged = null;
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) this.LookupGType().GetThresholdType().GetClassPtr()) + (long) class_abi.GetFieldOffset("draw"));
				unmanaged = (DrawNativeDelegate) Marshal.GetDelegateForFunctionPointer(*raw_ptr, typeof(DrawNativeDelegate));
			}
			if (unmanaged == null) return;

			unmanaged (this.Handle);
		}

		static RunNativeDelegate Run_cb_delegate;
		static RunNativeDelegate RunVMCallback {
			get {
				if (Run_cb_delegate == null)
					Run_cb_delegate = new RunNativeDelegate (Run_cb);
				return Run_cb_delegate;
			}
		}

		static void OverrideRun (GLib.GType gtype)
		{
			OverrideRun (gtype, RunVMCallback);
		}

		static void OverrideRun (GLib.GType gtype, RunNativeDelegate callback)
		{
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) gtype.GetClassPtr()) + (long) class_abi.GetFieldOffset("run"));
				*raw_ptr = Marshal.GetFunctionPointerForDelegate((Delegate) callback);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void RunNativeDelegate (IntPtr inst);

		static void Run_cb (IntPtr inst)
		{
			try {
				GLWindow __obj = GLib.Object.GetObject (inst, false) as GLWindow;
				__obj.OnRun ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gst.GL.GLWindow), ConnectionMethod="OverrideRun")]
		protected virtual void OnRun ()
		{
			InternalRun ();
		}

		private void InternalRun ()
		{
			RunNativeDelegate unmanaged = null;
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) this.LookupGType().GetThresholdType().GetClassPtr()) + (long) class_abi.GetFieldOffset("run"));
				unmanaged = (RunNativeDelegate) Marshal.GetDelegateForFunctionPointer(*raw_ptr, typeof(RunNativeDelegate));
			}
			if (unmanaged == null) return;

			unmanaged (this.Handle);
		}

		static QuitNativeDelegate Quit_cb_delegate;
		static QuitNativeDelegate QuitVMCallback {
			get {
				if (Quit_cb_delegate == null)
					Quit_cb_delegate = new QuitNativeDelegate (Quit_cb);
				return Quit_cb_delegate;
			}
		}

		static void OverrideQuit (GLib.GType gtype)
		{
			OverrideQuit (gtype, QuitVMCallback);
		}

		static void OverrideQuit (GLib.GType gtype, QuitNativeDelegate callback)
		{
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) gtype.GetClassPtr()) + (long) class_abi.GetFieldOffset("quit"));
				*raw_ptr = Marshal.GetFunctionPointerForDelegate((Delegate) callback);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void QuitNativeDelegate (IntPtr inst);

		static void Quit_cb (IntPtr inst)
		{
			try {
				GLWindow __obj = GLib.Object.GetObject (inst, false) as GLWindow;
				__obj.OnQuit ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gst.GL.GLWindow), ConnectionMethod="OverrideQuit")]
		protected virtual void OnQuit ()
		{
			InternalQuit ();
		}

		private void InternalQuit ()
		{
			QuitNativeDelegate unmanaged = null;
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) this.LookupGType().GetThresholdType().GetClassPtr()) + (long) class_abi.GetFieldOffset("quit"));
				unmanaged = (QuitNativeDelegate) Marshal.GetDelegateForFunctionPointer(*raw_ptr, typeof(QuitNativeDelegate));
			}
			if (unmanaged == null) return;

			unmanaged (this.Handle);
		}

		static SendMessageNativeDelegate SendMessage_cb_delegate;
		static SendMessageNativeDelegate SendMessageVMCallback {
			get {
				if (SendMessage_cb_delegate == null)
					SendMessage_cb_delegate = new SendMessageNativeDelegate (SendMessage_cb);
				return SendMessage_cb_delegate;
			}
		}

		static void OverrideSendMessage (GLib.GType gtype)
		{
			OverrideSendMessage (gtype, SendMessageVMCallback);
		}

		static void OverrideSendMessage (GLib.GType gtype, SendMessageNativeDelegate callback)
		{
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) gtype.GetClassPtr()) + (long) class_abi.GetFieldOffset("send_message"));
				*raw_ptr = Marshal.GetFunctionPointerForDelegate((Delegate) callback);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void SendMessageNativeDelegate (IntPtr inst, Gst.GLSharp.GLWindowCBNative cb, IntPtr data);

		static void SendMessage_cb (IntPtr inst, Gst.GLSharp.GLWindowCBNative cb, IntPtr data)
		{
			try {
				GLWindow __obj = GLib.Object.GetObject (inst, false) as GLWindow;
				Gst.GLSharp.GLWindowCBInvoker cb_invoker = new Gst.GLSharp.GLWindowCBInvoker (cb, data);
				__obj.OnSendMessage (cb_invoker.Handler);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gst.GL.GLWindow), ConnectionMethod="OverrideSendMessage")]
		protected virtual void OnSendMessage (Gst.GL.GLWindowCB cb)
		{
			InternalSendMessage (cb);
		}

		private void InternalSendMessage (Gst.GL.GLWindowCB cb)
		{
			SendMessageNativeDelegate unmanaged = null;
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) this.LookupGType().GetThresholdType().GetClassPtr()) + (long) class_abi.GetFieldOffset("send_message"));
				unmanaged = (SendMessageNativeDelegate) Marshal.GetDelegateForFunctionPointer(*raw_ptr, typeof(SendMessageNativeDelegate));
			}
			if (unmanaged == null) return;

			Gst.GLSharp.GLWindowCBWrapper cb_wrapper = new Gst.GLSharp.GLWindowCBWrapper (cb);
			cb_wrapper.PersistUntilCalled ();
			unmanaged (this.Handle, cb_wrapper.NativeDelegate, IntPtr.Zero);
		}

		static SendMessageAsyncNativeDelegate SendMessageAsync_cb_delegate;
		static SendMessageAsyncNativeDelegate SendMessageAsyncVMCallback {
			get {
				if (SendMessageAsync_cb_delegate == null)
					SendMessageAsync_cb_delegate = new SendMessageAsyncNativeDelegate (SendMessageAsync_cb);
				return SendMessageAsync_cb_delegate;
			}
		}

		static void OverrideSendMessageAsync (GLib.GType gtype)
		{
			OverrideSendMessageAsync (gtype, SendMessageAsyncVMCallback);
		}

		static void OverrideSendMessageAsync (GLib.GType gtype, SendMessageAsyncNativeDelegate callback)
		{
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) gtype.GetClassPtr()) + (long) class_abi.GetFieldOffset("send_message_async"));
				*raw_ptr = Marshal.GetFunctionPointerForDelegate((Delegate) callback);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void SendMessageAsyncNativeDelegate (IntPtr inst, Gst.GLSharp.GLWindowCBNative cb, IntPtr data, GLib.DestroyNotify destroy);

		static void SendMessageAsync_cb (IntPtr inst, Gst.GLSharp.GLWindowCBNative cb, IntPtr data, GLib.DestroyNotify destroy)
		{
			try {
				GLWindow __obj = GLib.Object.GetObject (inst, false) as GLWindow;
				Gst.GLSharp.GLWindowCBInvoker cb_invoker = new Gst.GLSharp.GLWindowCBInvoker (cb, data, destroy);
				__obj.OnSendMessageAsync (cb_invoker.Handler);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gst.GL.GLWindow), ConnectionMethod="OverrideSendMessageAsync")]
		protected virtual void OnSendMessageAsync (Gst.GL.GLWindowCB cb)
		{
			InternalSendMessageAsync (cb);
		}

		private void InternalSendMessageAsync (Gst.GL.GLWindowCB cb)
		{
			SendMessageAsyncNativeDelegate unmanaged = null;
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) this.LookupGType().GetThresholdType().GetClassPtr()) + (long) class_abi.GetFieldOffset("send_message_async"));
				unmanaged = (SendMessageAsyncNativeDelegate) Marshal.GetDelegateForFunctionPointer(*raw_ptr, typeof(SendMessageAsyncNativeDelegate));
			}
			if (unmanaged == null) return;

			Gst.GLSharp.GLWindowCBWrapper cb_wrapper = new Gst.GLSharp.GLWindowCBWrapper (cb);
			IntPtr data;
			GLib.DestroyNotify destroy;
			if (cb == null) {
				data = IntPtr.Zero;
				destroy = null;
			} else {
				data = (IntPtr) GCHandle.Alloc (cb_wrapper);
				destroy = GLib.DestroyHelper.NotifyHandler;
			}
			unmanaged (this.Handle, cb_wrapper.NativeDelegate, data, destroy);
		}

		static OpenNativeDelegate Open_cb_delegate;
		static OpenNativeDelegate OpenVMCallback {
			get {
				if (Open_cb_delegate == null)
					Open_cb_delegate = new OpenNativeDelegate (Open_cb);
				return Open_cb_delegate;
			}
		}

		static void OverrideOpen (GLib.GType gtype)
		{
			OverrideOpen (gtype, OpenVMCallback);
		}

		static void OverrideOpen (GLib.GType gtype, OpenNativeDelegate callback)
		{
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) gtype.GetClassPtr()) + (long) class_abi.GetFieldOffset("open"));
				*raw_ptr = Marshal.GetFunctionPointerForDelegate((Delegate) callback);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool OpenNativeDelegate (IntPtr inst, out IntPtr error);

		static bool Open_cb (IntPtr inst, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLWindow __obj = GLib.Object.GetObject (inst, false) as GLWindow;
				bool __result;
				__result = __obj.OnOpen ();
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gst.GL.GLWindow), ConnectionMethod="OverrideOpen")]
		protected virtual bool OnOpen ()
		{
			return InternalOpen ();
		}

		private bool InternalOpen ()
		{
			OpenNativeDelegate unmanaged = null;
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) this.LookupGType().GetThresholdType().GetClassPtr()) + (long) class_abi.GetFieldOffset("open"));
				unmanaged = (OpenNativeDelegate) Marshal.GetDelegateForFunctionPointer(*raw_ptr, typeof(OpenNativeDelegate));
			}
			if (unmanaged == null) throw new InvalidOperationException ("No base method to invoke");

			IntPtr error = IntPtr.Zero;
			bool __result = unmanaged (this.Handle, out error);
			return __result;
		}

		static CloseNativeDelegate Close_cb_delegate;
		static CloseNativeDelegate CloseVMCallback {
			get {
				if (Close_cb_delegate == null)
					Close_cb_delegate = new CloseNativeDelegate (Close_cb);
				return Close_cb_delegate;
			}
		}

		static void OverrideClose (GLib.GType gtype)
		{
			OverrideClose (gtype, CloseVMCallback);
		}

		static void OverrideClose (GLib.GType gtype, CloseNativeDelegate callback)
		{
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) gtype.GetClassPtr()) + (long) class_abi.GetFieldOffset("close"));
				*raw_ptr = Marshal.GetFunctionPointerForDelegate((Delegate) callback);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void CloseNativeDelegate (IntPtr inst);

		static void Close_cb (IntPtr inst)
		{
			try {
				GLWindow __obj = GLib.Object.GetObject (inst, false) as GLWindow;
				__obj.OnClose ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gst.GL.GLWindow), ConnectionMethod="OverrideClose")]
		protected virtual void OnClose ()
		{
			InternalClose ();
		}

		private void InternalClose ()
		{
			CloseNativeDelegate unmanaged = null;
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) this.LookupGType().GetThresholdType().GetClassPtr()) + (long) class_abi.GetFieldOffset("close"));
				unmanaged = (CloseNativeDelegate) Marshal.GetDelegateForFunctionPointer(*raw_ptr, typeof(CloseNativeDelegate));
			}
			if (unmanaged == null) return;

			unmanaged (this.Handle);
		}

		static HandleEventsNativeDelegate HandleEvents_cb_delegate;
		static HandleEventsNativeDelegate HandleEventsVMCallback {
			get {
				if (HandleEvents_cb_delegate == null)
					HandleEvents_cb_delegate = new HandleEventsNativeDelegate (HandleEvents_cb);
				return HandleEvents_cb_delegate;
			}
		}

		static void OverrideHandleEvents (GLib.GType gtype)
		{
			OverrideHandleEvents (gtype, HandleEventsVMCallback);
		}

		static void OverrideHandleEvents (GLib.GType gtype, HandleEventsNativeDelegate callback)
		{
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) gtype.GetClassPtr()) + (long) class_abi.GetFieldOffset("handle_events"));
				*raw_ptr = Marshal.GetFunctionPointerForDelegate((Delegate) callback);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void HandleEventsNativeDelegate (IntPtr inst, bool handle_events);

		static void HandleEvents_cb (IntPtr inst, bool handle_events)
		{
			try {
				GLWindow __obj = GLib.Object.GetObject (inst, false) as GLWindow;
				__obj.OnHandleEvents (handle_events);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gst.GL.GLWindow), ConnectionMethod="OverrideHandleEvents")]
		protected virtual void OnHandleEvents (bool handle_events)
		{
			InternalHandleEvents (handle_events);
		}

		private void InternalHandleEvents (bool handle_events)
		{
			HandleEventsNativeDelegate unmanaged = null;
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) this.LookupGType().GetThresholdType().GetClassPtr()) + (long) class_abi.GetFieldOffset("handle_events"));
				unmanaged = (HandleEventsNativeDelegate) Marshal.GetDelegateForFunctionPointer(*raw_ptr, typeof(HandleEventsNativeDelegate));
			}
			if (unmanaged == null) return;

			unmanaged (this.Handle, handle_events);
		}

		static SetPreferredSizeNativeDelegate SetPreferredSize_cb_delegate;
		static SetPreferredSizeNativeDelegate SetPreferredSizeVMCallback {
			get {
				if (SetPreferredSize_cb_delegate == null)
					SetPreferredSize_cb_delegate = new SetPreferredSizeNativeDelegate (SetPreferredSize_cb);
				return SetPreferredSize_cb_delegate;
			}
		}

		static void OverrideSetPreferredSize (GLib.GType gtype)
		{
			OverrideSetPreferredSize (gtype, SetPreferredSizeVMCallback);
		}

		static void OverrideSetPreferredSize (GLib.GType gtype, SetPreferredSizeNativeDelegate callback)
		{
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) gtype.GetClassPtr()) + (long) class_abi.GetFieldOffset("set_preferred_size"));
				*raw_ptr = Marshal.GetFunctionPointerForDelegate((Delegate) callback);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void SetPreferredSizeNativeDelegate (IntPtr inst, int width, int height);

		static void SetPreferredSize_cb (IntPtr inst, int width, int height)
		{
			try {
				GLWindow __obj = GLib.Object.GetObject (inst, false) as GLWindow;
				__obj.OnSetPreferredSize (width, height);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gst.GL.GLWindow), ConnectionMethod="OverrideSetPreferredSize")]
		protected virtual void OnSetPreferredSize (int width, int height)
		{
			InternalSetPreferredSize (width, height);
		}

		private void InternalSetPreferredSize (int width, int height)
		{
			SetPreferredSizeNativeDelegate unmanaged = null;
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) this.LookupGType().GetThresholdType().GetClassPtr()) + (long) class_abi.GetFieldOffset("set_preferred_size"));
				unmanaged = (SetPreferredSizeNativeDelegate) Marshal.GetDelegateForFunctionPointer(*raw_ptr, typeof(SetPreferredSizeNativeDelegate));
			}
			if (unmanaged == null) return;

			unmanaged (this.Handle, width, height);
		}

		static ShowNativeDelegate Show_cb_delegate;
		static ShowNativeDelegate ShowVMCallback {
			get {
				if (Show_cb_delegate == null)
					Show_cb_delegate = new ShowNativeDelegate (Show_cb);
				return Show_cb_delegate;
			}
		}

		static void OverrideShow (GLib.GType gtype)
		{
			OverrideShow (gtype, ShowVMCallback);
		}

		static void OverrideShow (GLib.GType gtype, ShowNativeDelegate callback)
		{
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) gtype.GetClassPtr()) + (long) class_abi.GetFieldOffset("show"));
				*raw_ptr = Marshal.GetFunctionPointerForDelegate((Delegate) callback);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ShowNativeDelegate (IntPtr inst);

		static void Show_cb (IntPtr inst)
		{
			try {
				GLWindow __obj = GLib.Object.GetObject (inst, false) as GLWindow;
				__obj.OnShow ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gst.GL.GLWindow), ConnectionMethod="OverrideShow")]
		protected virtual void OnShow ()
		{
			InternalShow ();
		}

		private void InternalShow ()
		{
			ShowNativeDelegate unmanaged = null;
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) this.LookupGType().GetThresholdType().GetClassPtr()) + (long) class_abi.GetFieldOffset("show"));
				unmanaged = (ShowNativeDelegate) Marshal.GetDelegateForFunctionPointer(*raw_ptr, typeof(ShowNativeDelegate));
			}
			if (unmanaged == null) return;

			unmanaged (this.Handle);
		}

		static SetRenderRectangleNativeDelegate SetRenderRectangle_cb_delegate;
		static SetRenderRectangleNativeDelegate SetRenderRectangleVMCallback {
			get {
				if (SetRenderRectangle_cb_delegate == null)
					SetRenderRectangle_cb_delegate = new SetRenderRectangleNativeDelegate (SetRenderRectangle_cb);
				return SetRenderRectangle_cb_delegate;
			}
		}

		static void OverrideSetRenderRectangle (GLib.GType gtype)
		{
			OverrideSetRenderRectangle (gtype, SetRenderRectangleVMCallback);
		}

		static void OverrideSetRenderRectangle (GLib.GType gtype, SetRenderRectangleNativeDelegate callback)
		{
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) gtype.GetClassPtr()) + (long) class_abi.GetFieldOffset("set_render_rectangle"));
				*raw_ptr = Marshal.GetFunctionPointerForDelegate((Delegate) callback);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool SetRenderRectangleNativeDelegate (IntPtr inst, int x, int y, int width, int height);

		static bool SetRenderRectangle_cb (IntPtr inst, int x, int y, int width, int height)
		{
			try {
				GLWindow __obj = GLib.Object.GetObject (inst, false) as GLWindow;
				bool __result;
				__result = __obj.OnSetRenderRectangle (x, y, width, height);
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gst.GL.GLWindow), ConnectionMethod="OverrideSetRenderRectangle")]
		protected virtual bool OnSetRenderRectangle (int x, int y, int width, int height)
		{
			return InternalSetRenderRectangle (x, y, width, height);
		}

		private bool InternalSetRenderRectangle (int x, int y, int width, int height)
		{
			SetRenderRectangleNativeDelegate unmanaged = null;
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) this.LookupGType().GetThresholdType().GetClassPtr()) + (long) class_abi.GetFieldOffset("set_render_rectangle"));
				unmanaged = (SetRenderRectangleNativeDelegate) Marshal.GetDelegateForFunctionPointer(*raw_ptr, typeof(SetRenderRectangleNativeDelegate));
			}
			if (unmanaged == null) return false;

			bool __result = unmanaged (this.Handle, x, y, width, height);
			return __result;
		}

		static QueueResizeNativeDelegate QueueResize_cb_delegate;
		static QueueResizeNativeDelegate QueueResizeVMCallback {
			get {
				if (QueueResize_cb_delegate == null)
					QueueResize_cb_delegate = new QueueResizeNativeDelegate (QueueResize_cb);
				return QueueResize_cb_delegate;
			}
		}

		static void OverrideQueueResize (GLib.GType gtype)
		{
			OverrideQueueResize (gtype, QueueResizeVMCallback);
		}

		static void OverrideQueueResize (GLib.GType gtype, QueueResizeNativeDelegate callback)
		{
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) gtype.GetClassPtr()) + (long) class_abi.GetFieldOffset("queue_resize"));
				*raw_ptr = Marshal.GetFunctionPointerForDelegate((Delegate) callback);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void QueueResizeNativeDelegate (IntPtr inst);

		static void QueueResize_cb (IntPtr inst)
		{
			try {
				GLWindow __obj = GLib.Object.GetObject (inst, false) as GLWindow;
				__obj.OnQueueResize ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gst.GL.GLWindow), ConnectionMethod="OverrideQueueResize")]
		protected virtual void OnQueueResize ()
		{
			InternalQueueResize ();
		}

		private void InternalQueueResize ()
		{
			QueueResizeNativeDelegate unmanaged = null;
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) this.LookupGType().GetThresholdType().GetClassPtr()) + (long) class_abi.GetFieldOffset("queue_resize"));
				unmanaged = (QueueResizeNativeDelegate) Marshal.GetDelegateForFunctionPointer(*raw_ptr, typeof(QueueResizeNativeDelegate));
			}
			if (unmanaged == null) return;

			unmanaged (this.Handle);
		}

		static ControlsViewportNativeDelegate ControlsViewport_cb_delegate;
		static ControlsViewportNativeDelegate ControlsViewportVMCallback {
			get {
				if (ControlsViewport_cb_delegate == null)
					ControlsViewport_cb_delegate = new ControlsViewportNativeDelegate (ControlsViewport_cb);
				return ControlsViewport_cb_delegate;
			}
		}

		static void OverrideControlsViewport (GLib.GType gtype)
		{
			OverrideControlsViewport (gtype, ControlsViewportVMCallback);
		}

		static void OverrideControlsViewport (GLib.GType gtype, ControlsViewportNativeDelegate callback)
		{
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) gtype.GetClassPtr()) + (long) class_abi.GetFieldOffset("controls_viewport"));
				*raw_ptr = Marshal.GetFunctionPointerForDelegate((Delegate) callback);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool ControlsViewportNativeDelegate (IntPtr inst);

		static bool ControlsViewport_cb (IntPtr inst)
		{
			try {
				GLWindow __obj = GLib.Object.GetObject (inst, false) as GLWindow;
				bool __result;
				__result = __obj.OnControlsViewport ();
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gst.GL.GLWindow), ConnectionMethod="OverrideControlsViewport")]
		protected virtual bool OnControlsViewport ()
		{
			return InternalControlsViewport ();
		}

		private bool InternalControlsViewport ()
		{
			ControlsViewportNativeDelegate unmanaged = null;
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) this.LookupGType().GetThresholdType().GetClassPtr()) + (long) class_abi.GetFieldOffset("controls_viewport"));
				unmanaged = (ControlsViewportNativeDelegate) Marshal.GetDelegateForFunctionPointer(*raw_ptr, typeof(ControlsViewportNativeDelegate));
			}
			if (unmanaged == null) return false;

			bool __result = unmanaged (this.Handle);
			return __result;
		}

		static HasOutputSurfaceNativeDelegate HasOutputSurface_cb_delegate;
		static HasOutputSurfaceNativeDelegate HasOutputSurfaceVMCallback {
			get {
				if (HasOutputSurface_cb_delegate == null)
					HasOutputSurface_cb_delegate = new HasOutputSurfaceNativeDelegate (HasOutputSurface_cb);
				return HasOutputSurface_cb_delegate;
			}
		}

		static void OverrideHasOutputSurface (GLib.GType gtype)
		{
			OverrideHasOutputSurface (gtype, HasOutputSurfaceVMCallback);
		}

		static void OverrideHasOutputSurface (GLib.GType gtype, HasOutputSurfaceNativeDelegate callback)
		{
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) gtype.GetClassPtr()) + (long) class_abi.GetFieldOffset("has_output_surface"));
				*raw_ptr = Marshal.GetFunctionPointerForDelegate((Delegate) callback);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool HasOutputSurfaceNativeDelegate (IntPtr inst);

		static bool HasOutputSurface_cb (IntPtr inst)
		{
			try {
				GLWindow __obj = GLib.Object.GetObject (inst, false) as GLWindow;
				bool __result;
				__result = __obj.OnHasOutputSurface ();
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gst.GL.GLWindow), ConnectionMethod="OverrideHasOutputSurface")]
		protected virtual bool OnHasOutputSurface ()
		{
			return InternalHasOutputSurface ();
		}

		private bool InternalHasOutputSurface ()
		{
			HasOutputSurfaceNativeDelegate unmanaged = null;
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) this.LookupGType().GetThresholdType().GetClassPtr()) + (long) class_abi.GetFieldOffset("has_output_surface"));
				unmanaged = (HasOutputSurfaceNativeDelegate) Marshal.GetDelegateForFunctionPointer(*raw_ptr, typeof(HasOutputSurfaceNativeDelegate));
			}
			if (unmanaged == null) return false;

			bool __result = unmanaged (this.Handle);
			return __result;
		}

		[DllImport("gstgl-1.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gst_gl_window_get_type();

		public static new GLib.GType GType { 
			get {
				IntPtr raw_ret = gst_gl_window_get_type();
				GLib.GType ret = new GLib.GType(raw_ret);
				return ret;
			}
		}

		[DllImport("gstgl-1.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gst_gl_window_controls_viewport(IntPtr raw);

		public bool ControlsViewport() {
			bool raw_ret = gst_gl_window_controls_viewport(Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("gstgl-1.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gst_gl_window_draw(IntPtr raw);

		public void Draw() {
			gst_gl_window_draw(Handle);
		}

		[DllImport("gstgl-1.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gst_gl_window_get_context(IntPtr raw);

		public Gst.GL.GLContext Context { 
			get {
				IntPtr raw_ret = gst_gl_window_get_context(Handle);
				Gst.GL.GLContext ret = GLib.Object.GetObject(raw_ret, true) as Gst.GL.GLContext;
				return ret;
			}
		}

		[DllImport("gstgl-1.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gst_gl_window_get_surface_dimensions(IntPtr raw, out uint width, out uint height);

		public void GetSurfaceDimensions(out uint width, out uint height) {
			gst_gl_window_get_surface_dimensions(Handle, out width, out height);
		}

		[DllImport("gstgl-1.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern UIntPtr gst_gl_window_get_window_handle(IntPtr raw);

		[DllImport("gstgl-1.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gst_gl_window_set_window_handle(IntPtr raw, UIntPtr handle);

		public ulong WindowHandle { 
			get {
				UIntPtr raw_ret = gst_gl_window_get_window_handle(Handle);
				ulong ret = (ulong) raw_ret;
				return ret;
			}
			set {
				gst_gl_window_set_window_handle(Handle, new UIntPtr (value));
			}
		}

		[DllImport("gstgl-1.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gst_gl_window_handle_events(IntPtr raw, bool handle_events);

		public void HandleEvents(bool handle_events) {
			gst_gl_window_handle_events(Handle, handle_events);
		}

		[DllImport("gstgl-1.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gst_gl_window_has_output_surface(IntPtr raw);

		public bool HasOutputSurface { 
			get {
				bool raw_ret = gst_gl_window_has_output_surface(Handle);
				bool ret = raw_ret;
				return ret;
			}
		}

		[DllImport("gstgl-1.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gst_gl_window_queue_resize(IntPtr raw);

		public void QueueResize() {
			gst_gl_window_queue_resize(Handle);
		}

		[DllImport("gstgl-1.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gst_gl_window_quit(IntPtr raw);

		public void Quit() {
			gst_gl_window_quit(Handle);
		}

		[DllImport("gstgl-1.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gst_gl_window_resize(IntPtr raw, uint width, uint height);

		public void Resize(uint width, uint height) {
			gst_gl_window_resize(Handle, width, height);
		}

		[DllImport("gstgl-1.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gst_gl_window_run(IntPtr raw);

		public void Run() {
			gst_gl_window_run(Handle);
		}

		[DllImport("gstgl-1.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gst_gl_window_send_key_event(IntPtr raw, IntPtr event_type, IntPtr key_str);

		public void SendKeyEvent(string event_type, string key_str) {
			IntPtr native_event_type = GLib.Marshaller.StringToPtrGStrdup (event_type);
			IntPtr native_key_str = GLib.Marshaller.StringToPtrGStrdup (key_str);
			gst_gl_window_send_key_event(Handle, native_event_type, native_key_str);
			GLib.Marshaller.Free (native_event_type);
			GLib.Marshaller.Free (native_key_str);
		}

		[DllImport("gstgl-1.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gst_gl_window_send_message(IntPtr raw, Gst.GLSharp.GLWindowCBNative cb, IntPtr data);

		public void SendMessage(Gst.GL.GLWindowCB cb) {
			Gst.GLSharp.GLWindowCBWrapper cb_wrapper = new Gst.GLSharp.GLWindowCBWrapper (cb);
			cb_wrapper.PersistUntilCalled ();
			gst_gl_window_send_message(Handle, cb_wrapper.NativeDelegate, IntPtr.Zero);
		}

		[DllImport("gstgl-1.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gst_gl_window_send_message_async(IntPtr raw, Gst.GLSharp.GLWindowCBNative cb, IntPtr data, GLib.DestroyNotify destroy);

		public void SendMessageAsync(Gst.GL.GLWindowCB cb) {
			Gst.GLSharp.GLWindowCBWrapper cb_wrapper = new Gst.GLSharp.GLWindowCBWrapper (cb);
			IntPtr data;
			GLib.DestroyNotify destroy;
			if (cb == null) {
				data = IntPtr.Zero;
				destroy = null;
			} else {
				data = (IntPtr) GCHandle.Alloc (cb_wrapper);
				destroy = GLib.DestroyHelper.NotifyHandler;
			}
			gst_gl_window_send_message_async(Handle, cb_wrapper.NativeDelegate, data, destroy);
		}

		[DllImport("gstgl-1.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gst_gl_window_send_mouse_event(IntPtr raw, IntPtr event_type, int button, double posx, double posy);

		public void SendMouseEvent(string event_type, int button, double posx, double posy) {
			IntPtr native_event_type = GLib.Marshaller.StringToPtrGStrdup (event_type);
			gst_gl_window_send_mouse_event(Handle, native_event_type, button, posx, posy);
			GLib.Marshaller.Free (native_event_type);
		}

		[DllImport("gstgl-1.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gst_gl_window_send_scroll_event(IntPtr raw, double posx, double posy, double delta_x, double delta_y);

		public void SendScrollEvent(double posx, double posy, double delta_x, double delta_y) {
			gst_gl_window_send_scroll_event(Handle, posx, posy, delta_x, delta_y);
		}

		[DllImport("gstgl-1.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gst_gl_window_set_close_callback(IntPtr raw, Gst.GLSharp.GLWindowCBNative cb, IntPtr data, GLib.DestroyNotify destroy_notify);

		public Gst.GL.GLWindowCB CloseCallback { 
			set {
				Gst.GLSharp.GLWindowCBWrapper value_wrapper = new Gst.GLSharp.GLWindowCBWrapper (value);
				IntPtr data;
				GLib.DestroyNotify destroy_notify;
				if (value == null) {
					data = IntPtr.Zero;
					destroy_notify = null;
				} else {
					data = (IntPtr) GCHandle.Alloc (value_wrapper);
					destroy_notify = GLib.DestroyHelper.NotifyHandler;
				}
				gst_gl_window_set_close_callback(Handle, value_wrapper.NativeDelegate, data, destroy_notify);
			}
		}

		[DllImport("gstgl-1.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gst_gl_window_set_draw_callback(IntPtr raw, Gst.GLSharp.GLWindowCBNative cb, IntPtr data, GLib.DestroyNotify destroy_notify);

		public Gst.GL.GLWindowCB DrawCallback { 
			set {
				Gst.GLSharp.GLWindowCBWrapper value_wrapper = new Gst.GLSharp.GLWindowCBWrapper (value);
				IntPtr data;
				GLib.DestroyNotify destroy_notify;
				if (value == null) {
					data = IntPtr.Zero;
					destroy_notify = null;
				} else {
					data = (IntPtr) GCHandle.Alloc (value_wrapper);
					destroy_notify = GLib.DestroyHelper.NotifyHandler;
				}
				gst_gl_window_set_draw_callback(Handle, value_wrapper.NativeDelegate, data, destroy_notify);
			}
		}

		[DllImport("gstgl-1.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gst_gl_window_set_preferred_size(IntPtr raw, int width, int height);

		public void SetPreferredSize(int width, int height) {
			gst_gl_window_set_preferred_size(Handle, width, height);
		}

		[DllImport("gstgl-1.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gst_gl_window_set_render_rectangle(IntPtr raw, int x, int y, int width, int height);

		public bool SetRenderRectangle(int x, int y, int width, int height) {
			bool raw_ret = gst_gl_window_set_render_rectangle(Handle, x, y, width, height);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("gstgl-1.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gst_gl_window_set_resize_callback(IntPtr raw, Gst.GLSharp.GLWindowResizeCBNative cb, IntPtr data, GLib.DestroyNotify destroy_notify);

		public Gst.GL.GLWindowResizeCB ResizeCallback { 
			set {
				Gst.GLSharp.GLWindowResizeCBWrapper value_wrapper = new Gst.GLSharp.GLWindowResizeCBWrapper (value);
				IntPtr data;
				GLib.DestroyNotify destroy_notify;
				if (value == null) {
					data = IntPtr.Zero;
					destroy_notify = null;
				} else {
					data = (IntPtr) GCHandle.Alloc (value_wrapper);
					destroy_notify = GLib.DestroyHelper.NotifyHandler;
				}
				gst_gl_window_set_resize_callback(Handle, value_wrapper.NativeDelegate, data, destroy_notify);
			}
		}

		[DllImport("gstgl-1.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gst_gl_window_show(IntPtr raw);

		public void Show() {
			gst_gl_window_show(Handle);
		}


		static GLWindow ()
		{
			GtkSharp.GstreamerSharp.ObjectManager.Initialize ();
		}
#endregion
	}
}
